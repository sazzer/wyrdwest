# Reactive ECS

## Definitions

* System - The actual code that performs actions
* Component - A single piece of data about a single Entity
* Entity - The collection of components for the same Entity ID
* Reactive - Systems are triggered by events that occur elsewhere in the universe rather than on a schedule

## Data

### Component

A Component has a minumum of two pieces of data:
* Component ID
* Entity ID

It may have an arbitrary amount of other data as appropriate, defined by the Component ID.

Components are all stored in some Component Data Store - this may be in-memory or a traditional database. The exact mechanics are unimportant, as long as they an efficiently be queried.

#### Example Component

The following example component represents the current health of an entity:
```json
{
    "componentId": "tag:rxecs,2019:components/health",
    "entityId": "tag:execs,2019:entities/F9A960A2-678B-4365-9775-27C2F03013CA",
    "health": 215
}
```

### Entity

An Entity doesn't actually exist as any data in it's own right, and is instead simply the collection of Components that have the same Entity ID

### Event

Events are sent by various elements in the universe and are used to trigger Systems. These have a minimum of two pieces of data:
* Event Type
* Event Source

The Event Source may be an Entity, but it may also be something more abstract. For example, a typical event source would be the universal clock generating ticks.

Events may also have an arbitrary amount of other data as appropriate, defined by the Event Type.

Events are not stored for purposes of the game. They may be persisted for auditing purposes to be able to rebuild exactly what has happened. Instead they are generated, processed and are no longer needed.

#### Example Event

The following example event represents the universal clock generating a tick:
```json
{
    "eventType": "tag:rxecs,2019:events/tick",
    "eventSource": "tag:rxecs,2019:clock",
    "timestamp": "2019-04-24T17:11:15Z"
}
```

## Event Flow

Events occur all the time within the game universe. These are generated by a large variety of different sources. However, they all are generated on to a single global event stream. (For example, Kafka or an RX Subject).

Every System subscribes to the global Event Stream and listens for events. However, each system only listens for events that they are interested in and reacts to those. All other events are ignored.

Every time an Event is generated, all Systems that are interested in it will React to that Event. This can cause immediate propagation of events throughout the universe, since reacting to one event will potentially generate yet more.

It may be important that Systems complete one event before processing the next one. It may also be important that events are not skipped if the previous one took too long to process. This will need to be determined on a case-by-case basis. For example:
* The "Tick" event only ever needs to process the most recent one, and if one tick takes too long to process then it is acceptable to skip ones that have backed up.
* The "User Input" events must be processed in strict order, never processing one until the previous one has finished. Additionally, there may be an enforced *minimum* time between these events being processed.
* The "Wounded" events can be processed immediately on being received, regardless of whether other events are currently being processed.

### Example Event Reaction
For example, a `BleedingSystem` might be interested in events for `tag:rxecs,2019:events/tick` and `tag:rxecs,2019:events/wounded`.

In the case of the Wounded event, the entity that was wounded is checked to see if their health is now less than 10. If so then they gain the `tag:rxecs,2019:components/bleeding` Component with a `nextBleed` time set to `now + 10s`.

In the case of the Tick event, the system will locate all Entities in the data store that have the `tag:rxecs,2019:components/bleeding` with a `nextBleed` time that is in the past. These Entities will then have their health reduced by 1.

If the system reduces the entities health to 0 then the entity is dead, in which case:
* The `tag:rxecs,2019:components/bleeding` component is removed.
* The `tag:rxecs,2019:components/dead` component is added.
* The `tag:rxecs,2019:events/died` event is generated to indicate that the entity has died.

Other systems will then react to this event as appropriate.

## User Input

Under this system, certain types of user input can be considered as simply another event on the event stream. Appropriate systems will see the event and react accordingly. It is likely that only a single system will be interested in these events, but that system may well generate more events accordingly.

For example, there may be a system that reacts to the `tag:rxecs,2019:events/user-input/speak` event and, if the character is capable of speaking, will then emit the `tag:rxecs,2019:events/speech` event. Due to the chaining of events, this will then be received and processed by systems that might react to the speech - for example, an AI based System for an NPC in the same room.

Other types of user input do not affect the game world but are instead an immediate response for the player. For example, the user may wish to request to see the characters inventory. This does not have any impact on the universe, so no event need be generated. Instead the user input would immediately load the appropriate components from the data store, build the appropriate response and send this back.

Note that this *could* be handled using events and systems, but this is almost certainly excessive.

## User Output

User Output can be facilitated by the I/O code also listening to the event stream and sending messages to the client based on the events that go past. This will require filtering the events to be applicable to that character - e.g. speech must be within a disstance where it could actually be heard. These events can then be converted into the appropriate output format to send to the client - be that Telnet messages or JSON payloads over a WebSockets connection.

## Reacting to Component Changes

It seems reasonable that any changes to components - creation, removal or updates - could trigger events. However, this will very quickly overwhelm the system with the number of events being generated.

Instead, each component could be configured to indicate if it should generate events for these changes, and which event they should generate. This would allow certain changes to automatically propagate without the risk of flooding the event stream.

For example, it would be reasonable to trigger an event every time the `tag:rxecs,2019:components/health` component has it's value changed, but less reasonable to do the same for the `tag:rxecs,2019:components/stamina` component.

This then leads to an interesting compromise on the granularity of components. Fine grained components can more easily be used to trigger events on changes, but will suffer an overhead of actually loading and persisting them to the data store. Course grained components are more efficient in the data store but will potentially lead to events being triggered needlessly.

## Example System - RxJS

The following is an example System built using the RxJS library. This is constructed with the Subject to send events to, and on which to subscribe to events in the first place.

```js
function bleedingSystem(subject, componentsStore) {
    // React to all Wounded events to make the entity Bleed
    subject.pipe(
        filter((event) => event.type === 'tag:rxecs,2019:events/wounded')
    ).subscribe((event) => {

        const health = componentsStore.findOne('tag:rxecs,2019:components/health', {entityId: event.target});
        if (health && health.health <= 10) {
            componentsStore.createComponent({
                'componentId': 'tag:rxecs,2019:components/bleeding',
                'entityId': event.target,
                'nextBleed': computeNextBleed()
            });
            subject.next({
                type: 'tag:execs,2019:events/bleeding',
                source: event.target
            });
        }
    });

    // React to all Tick events to reduce the health by 1, and if it reaches 0 to emit a Died event
    subject.pipe(
        filter((event) => event.type === 'tag:rxecs,2019:events/tick')
    ).subscribe((event) => {

        componentsStore.findAll('tag:rxecs,2019:components/bleeding', {nextBleed: now})
            .map((entityId) => componentStore.findOne('tag:rxecs,2019:components/health', {entityId: component.entityId}))
            .forEach((health) => {
                health.health -= 1;
                componentStore.persist(health);
                if (health.health === 0) {
                    subject.next({
                        type: 'tag:rxecs,2019:events/died',
                        source: health.entityId
                    });
                    componentStore.remove('tag:rxecs,2019:components/bleeding', health.entityId);
                    componentsStore.createComponent({
                        'componentId': 'tag:rxecs,2019:components/dead',
                        'entityId': event.target
                    });
                }
            });
    });
}
```
